% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RATE.R
\name{rate_estimation}
\alias{rate_estimation}
\title{RATE Estimation}
\usage{
rate_estimation(cates, scores, beneficial = TRUE, n_boot = 200)
}
\arguments{
\item{cates}{Estimated CATEs. Must be out-of-sample predictions on the validation sample.}

\item{scores}{Estimated doubly-robust scores. Must be estimated via K-fold cross-fitting using a validation sample.}

\item{beneficial}{Logical, whether the treatment is beneficial to units. If \code{TRUE}, units are ranked according to decreasing values of \code{cates}, otherwise they are ranked according to increasing values of \code{cates}.}

\item{n_boot}{Number of bootstrap replications to estimate standard errors.}
}
\value{
A list storing a data frame for the TOC results, a list with two data frames for the AUTOC and QINI results, and a
data frame for the bootstrap results.
}
\description{
Estimates the rank-weighted average treatment effects (RATEs) induced by the estimated CATEs.
}
\details{
To estimate the RATEs induced the estimated CATEs, the user must provide the estimated CATEs and doubly-robust scores. Be careful, as the CATEs must be estimated only with 
using the training sample, while the doubly-robust scores must be estimated in the validation sample using K-fold cross fitting (see the example section below).\cr

\code{\link{rate_estimation}} first calls the \code{\link{toc_estimation}} function to estimate the TOCs, and then computes two RATEs, the AUTOC and the QINI coefficient, 
as weighted averages of the TOCs. Check the \href{https://riccardo-df.github.io/evaluCATE/articles/evalu-cates-short-tutorial.html}{online vignette} 
for details.\cr

Standard errors are estimated using the standard deviation of the bootstrap estimates obtained using the half-sample bootstrap.
}
\examples{
\donttest{## Generate data.
set.seed(1986)

n <- 1000
k <- 2

X <- matrix(rnorm(n * k), ncol = k)
colnames(X) <- paste0("x", seq_len(k))
D <- rbinom(n, size = 1, prob = 0.5)
mu0 <- 0.5 * X[, 1]
mu1 <- 0.5 * X[, 1] + X[, 2]
Y <- mu0 + D * (mu1 - mu0) + rnorm(n)

## Sample split.
train_idx <- sample(c(TRUE, FALSE), length(Y), replace = TRUE)

X_tr <- X[train_idx, ]
X_val <- X[!train_idx, ]

D_tr <- D[train_idx]
D_val <- D[!train_idx]

Y_tr <- Y[train_idx]
Y_val <- Y[!train_idx]

## CATEs and nuisance functions estimation.
## We use only the training sample for estimation.
## We predict on the validation sample.
library(grf)

cates_forest <- causal_forest(X_tr, Y_tr, D_tr) 
cates_val <- predict(cates_forest, X_val)$predictions 

## AIPW scores estimation.
## Cross-fitting on the validation sample.
library(aggTrees)
scores_val <- dr_scores(Y_val, D_val, X_val)

## RATE estimation. 
rate_results <- rate_estimation(cates_val, scores_val)}

}
\seealso{
\code{\link{blp_estimation}}, \code{\link{gates_estimation}}, \code{\link{toc_estimation}}
}
\author{
Riccardo Di Francesco
}
